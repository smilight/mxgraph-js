import fs from 'fs';
import path from 'path';

const LEGACY_ROOT = path.resolve('javascript/src/js');
const CORE_ROOT = path.resolve('src/core');
const ENTRY_ROOT = path.resolve('src/entrypoints');
const EXPORTS_JS = path.join(CORE_ROOT, 'exports.js');
const EXPORTS_TS = path.join(CORE_ROOT, 'exports.ts');

function toRelativeImport(from, to) {
  const rel = toPosix(path.relative(path.dirname(from), to));
  if (rel.startsWith('.')) return rel;
  return `./${rel}`;
}

function toPosix(p) {
  return p.split(path.sep).join('/');
}

function ensureDir(dir) {
  fs.mkdirSync(dir, { recursive: true });
}

function findLegacyModules() {
  const results = [];
  const stack = [LEGACY_ROOT];
  while (stack.length) {
    const dir = stack.pop();
    const entries = fs.readdirSync(dir, { withFileTypes: true });
    for (const entry of entries) {
      const abs = path.join(dir, entry.name);
      if (entry.isDirectory()) {
        stack.push(abs);
        continue;
      }
      if (!entry.isFile()) continue;
      if (!entry.name.endsWith('.js')) continue;
      if (!entry.name.startsWith('mx')) continue;
      const rel = path.relative(LEGACY_ROOT, abs);
      const symbol = path.basename(entry.name, '.js');
      results.push({ rel, symbol });
    }
  }
  return results.sort((a, b) => a.symbol.localeCompare(b.symbol));
}

function writeFileIfChanged(filePath, contents) {
  if (fs.existsSync(filePath)) {
    const current = fs.readFileSync(filePath, 'utf8');
    if (current === contents) return false;
  }
  ensureDir(path.dirname(filePath));
  fs.writeFileSync(filePath, contents, 'utf8');
  return true;
}

function generateCoreShim({ rel, symbol }) {
  const tsPath = path.join(CORE_ROOT, rel.replace(/\.js$/, '.ts'));
  const relToExports = toRelativeImport(tsPath, EXPORTS_JS);
  const body = `// AUTO-GENERATED BY scripts/generate-entrypoints.mjs. DO NOT EDIT.\nexport { ${symbol} } from '${relToExports}';\n`;
  writeFileIfChanged(tsPath, body);
  return tsPath;
}

function generateEntrypoint({ rel, symbol }) {
  const coreTsPath = path.join(CORE_ROOT, rel.replace(/\.js$/, '.ts'));
  const entryPath = path.join(ENTRY_ROOT, `${symbol}.ts`);
  const relToCore = toRelativeImport(entryPath, coreTsPath).replace(/\.ts$/, '.js');
  const body = `// AUTO-GENERATED BY scripts/generate-entrypoints.mjs. DO NOT EDIT.\nexport { ${symbol} } from '${relToCore}';\n`;
  writeFileIfChanged(entryPath, body);
  return entryPath;
}

function cleanupGenerated(baseDir, expectedFiles) {
  if (!fs.existsSync(baseDir)) return;
  const seen = new Set(expectedFiles.map((p) => path.resolve(p)));
  const stack = [baseDir];
  while (stack.length) {
    const dir = stack.pop();
    for (const entry of fs.readdirSync(dir, { withFileTypes: true })) {
      const abs = path.join(dir, entry.name);
      if (entry.isDirectory()) {
        stack.push(abs);
        continue;
      }
      if (!entry.name.endsWith('.ts') && !entry.name.endsWith('.js')) continue;
      const resolved = path.resolve(abs);
      if (!seen.has(resolved)) {
        const content = fs.readFileSync(resolved, 'utf8');
        if (content.includes('AUTO-GENERATED BY scripts/generate-entrypoints.mjs')) {
          fs.unlinkSync(resolved);
        }
      }
    }
  }
}

function main() {
  const modules = findLegacyModules();
  const generatedCore = [];
  const generatedEntry = [];

  for (const mod of modules) {
    generatedCore.push(generateCoreShim(mod));
    generatedEntry.push(generateEntrypoint(mod));
  }

  // regenerate exports.ts to cover all symbols
  const symbols = Array.from(new Set(modules.map((m) => m.symbol))).sort();
  const header =
    '// AUTO-GENERATED BY scripts/generate-entrypoints.mjs. DO NOT EDIT.\n' +
    '// Live bindings to legacy mxGraph globals for tree-shakeable ESM.\n' +
    '/* eslint-disable @typescript-eslint/no-explicit-any */\n' +
    'export type MxGraphNamespace = Record<string, any>;\n' +
    "export type * from '../generated-dts/index.js';\n\n";
  const lines = symbols.map((s) => `export let ${s}: any;\n`);
  const wire = [
    '\nexport function wireMxNamespace(mx: MxGraphNamespace): void {\n',
    ...symbols.map((s) => `  ${s} = mx['${s}'] ?? (globalThis as any)['${s}'];\n`),
    '}\n',
    '\nexport function assertMxGraphReady(): void {\n',
    "  if (!mxGraph || !mxClient) {\n",
    "    throw new Error('mxgraph-js is not initialized. Call initMxGraph() from \"mxgraph-js/init\" first.');\n",
    '  }\n',
    '}\n'
  ];
  if (writeFileIfChanged(EXPORTS_TS, header + lines.join('') + wire.join(''))) {
    generatedCore.push(EXPORTS_TS);
  } else {
    generatedCore.push(EXPORTS_TS);
  }

  cleanupGenerated(CORE_ROOT, generatedCore);
  cleanupGenerated(ENTRY_ROOT, generatedEntry);
  console.log(`Generated ${generatedEntry.length} entrypoints from legacy sources.`);
}

main();
